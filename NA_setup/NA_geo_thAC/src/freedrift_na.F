c
c ----------------------------------------------------------------------------
c
c	An example of a driver program that calls the 
c	Neighbourhood algorithm routines to search a 
c	parameter space. See HTML manual for more details.
c					
c                                               M. Sambridge, RSES, ANU.
c						Last updated Sept. 1999.
c
c ----------------------------------------------------------------------------
c 
        program freedrift_na

c					MEMORY AND ARRAY SIZES
c
c					The NA routines use the
c					following include file to define
c					all parameters controlling
c					memory required by the arrays.
c
c					A description of each parameter,
c					indicating which ones should be 
c					changed to fit your application
c					can be found in 'na_param.inc' 
c
c	include 	'na_param.inc'
c
c					INPUT AND OUTPUT
c       Input files:
c                   na.in       	Contains options for Neighbourhood 
c					algorithm (see HTML manual)
c
c       Output files:
c                   na.sum      	summary of results
c
c                   na.nad      	NAD (NA direct access file of models)
c
c                   sobol.coeff 	initializing data used for
c                               	quasi-random sequences
c					(This is output for reference only)
c
c       Comments:
c                The NAD file is a direct access compact format file
c                containing all models generated by the neighbourhood
c                algorithm. (NAD files can be read in by multi-dimensional
c                integration program NA-Bayes and plot program S-plot.)
c
c		 Logical units 30-40 are reserved for use by NA subroutines
c		 The user specific routines should not use these values
c		 for logical units.
c		 The NA routines also write to LU 6 as standard out.
c
c ----------------------------------------------------------------------------
	n_iter = 0

c					Call NA routine to do the work		

        call na

        stop
        end
c
c ----------------------------------------------------------------------------
c
c	THE FOLLOWING IS AN EXAMPLE OF THE THREE ROUTINES,
c	CALLED BY THE NA ROUTINES, WHICH THE USER MUST SUPPLY. 
c
c	user_init - defines parametrization and can be
c		    used to perform any user initialization 
c		    (e.g. reading in data etc.) 
c
c	forward   - performs forward modelling on an input model
c		    and returns the misfit value of that model.
c
c	writemodels - a routine called after the NA has completed.
c		      All models and misfits are supplied 
c		      to the routine and here the user may write  
c		      then out in their own format.
c		      (Note that the NA routines only write the
c		       models out in a direct access NAD file.
c		       see HTML manual for details.)
c
c	THIS EXAMPLE IS FOR A CRUSTAL RECEIVER FUNCTION INVERSION PROBLEM. 
c
c		In this case the routines perform the following tasks:
c		read in data, define the parametrization,
c		calculate synthetics, define a misfit function and
c		write out various information to ascii files.
c
c	See HTMl manual for more details. An explanation of
c	calling the sequence and meaning is attached to each routine. 
c
c
c       This code is based on work by T. Shibutani (RCEP, DPRI, KYOTO UNIV.)
c	who wrote the receiver function routines.
c
c	Modifications by M. Sambridge (RSES, ANU) for use 
c	with a Neighbourhood algorithm.
c
c						M. Sambridge (RSES, ANU)
c
c-------------------------------------------------------------------------
c
c	user_init - performs all user specific initialization tasks. 
c		    In this case for receiver receiver function inversion.
c
c	Input: - iproc		:processor id (for MPI compilation).
c                                This allows the root node (id=0) to 
c				 emit debug iformation during user_init. 
c				 For serial option id=0.
c
c	Output:
c	      nd		:Number of dimensions in parameter space
c	      ranges(2,nd)	:bounds on parameter space
c	      scales(nd+1)	:scale factors in parameter space
c
c	Comments:
c		 The scale factors are used to transform the model
c		 parameter space into a non-dimensional space. They 
c		 must be provided by the user to put each parameter
c		 on an equal footing.  In the transformation
c		 the i-th parameter becomes,
c		
c		 xi_after = (xi_before-ranges(1,i))/scales(i+1).
c
c		 Note that scales(i+1) contains the scale factor for 
c		 the i-th parameter. The value of scales(1) can be used 
c		 as a shortcut to indicate common choices for scale 
c		 factors. If scales(1) = 0 then all scale factors are
c		 reset to 1; if scales(1) = -1 then the scale factors 
c		 are reset to the parameter range, i.e.,
c
c		 scales(i+1) = ranges(2,i)-ranges(1,i)
c
c		 and for any other value the scale factors are left unchanged.
c		 Note that if scales(1) is set to 0 or -1 then there is
c		 no need to fill up the scales array.
c
c		 This routine is only set up for a 6 layer 24 dimensional 
c		 receiver function problem. 
c
c				M. Sambridge, RSES (ANU), April 1998. 
c
c-------------------------------------------------------------------------
c 
        subroutine user_init(nd,ranges,scales)

c						initialize receiver
c						function forward modelling
        include 'freedrift_subs/freedrift_param.inc'
c 
        real*4          ranges(2,*),
     &                  scales(*)
c 

        logical         verbose,debug,timing,summary
        logical         lroot
        integer         nbals
        integer         nbals_max
        integer         bflag, bflag_sum, flag_lim

	parameter 	(nbals_max = 100)

        integer         all_flags(nbals_max)
        real            bal_inc(nbals_max)

        real            nbals_in
        real 		n2a_min, n2a_max, rop_min, rop_max
	real		thA_min, thA_max, thO_min, thO_max
	real		uwind(nbals_max), vwind(nbals_max), wind_mag(nbals_max)
	real		wind_sig(nbals_max)
	real		uo_i(nbals_max), vo_i(nbals_max), o_i_mag(nbals_max)
	real		ugeo(nbals_max), vgeo(nbals_max), geo_mag(nbals_max)
	real		o_i_sig(nbals_max), geo_sig(nbals_max)
        real            beta_a(nbals_max), beta_i(nbals_max) 
        real            beta_g(nbals_max), beta_fb(nbals_max)
	real		fc, rhoa, rhoi, rhoo
	real		hifc(nbals_max)  
	real		thAC
	real		Na
        real            pi
        real            data1, data2, data3
        parameter       ( pi = 3.141259E0 )
c	parameter 	( rhoa = 1.25E0 )
c	parameter 	( rhoi = 917.0E0 )
c	parameter 	( rhoo = 1026.0E0 )
c	parameter 	( fc   = 1.46E-4 )
c	parameter 	( hice = 1.0E-0 )
c						Info and Logical unit common 
c						blocks used by NA routines
c 
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                  lu_nad,verbose,debug,timing,summary

        common /NAMPI/iproc,nproc,lroot

        common /freedrift_com/ nbals,
     &			uwind, vwind, wind_mag, wind_sig,
     &                  uo_i, vo_i, o_i_mag, o_i_sig,
     &                  ugeo, vgeo, geo_mag, geo_sig,
     &                  beta_a, beta_i, beta_g, beta_fb,
     &                  rhoa, rhoi, rhoo, hifc, 
     &                  thAC,
     &                  Ca_min, Ca_max, Co_min, Co_max,
     &                  thA_min, thA_max, thO_min, thO_max


c
c		Set up logical units 
c						LU's for standard input and 
        

        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' User routines output'  
        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' Opening freedrift files...'
	if(lroot)write(lu_out,*)
c

c       Values for freedrift
 	
	lu_freedrift = 15

	
        open(lu_freedrift,file=
     &'/Users/H/INVERSE/Sylvia_data/NA_setup/NA_geo_thAC/freedrift_IC')

        read(lu_freedrift,*) nbals_in
        close(lu_freedrift)

        nbals = int(nbals_in)
        write(*,*) 'Number of balances this time  = ',nbals_in, nbals 

        lu_freedrift  = 16

	bflag     = 0
	bflag_sum = 0

	all_flags(:) = 0
	flag_lim     = 500
	bal_inc(:)   = 1.0E0
	
c
c						Open freedrift files
	open(lu_freedrift,file='/Users/H/INVERSE/Sylvia_data/NA_setup/NA_geo_thAC/freedrift_IC')

	read(lu_freedrift,*) nbals_in,  
     &			uwind(1:nbals), vwind(1:nbals), wind_mag(1:nbals), wind_sig(1:nbals),
     &                  uo_i(1:nbals), vo_i(1:nbals), o_i_mag(1:nbals), o_i_sig(1:nbals),
     &                  ugeo(1:nbals), vgeo(1:nbals), geo_mag(1:nbals), geo_sig(1:nbals),
     &                  beta_a(1:nbals), beta_i(1:nbals), beta_g(1:nbals), beta_fb(1:nbals),
     &                  hifc(1:nbals), rhoa, rhoi, rhoo,  
     &                  thAC,
     &                  n2a_min, n2a_max, rop_min, rop_max,
     &                  thA_min, thA_max, thO_min, thO_max
	close(lu_freedrift)

        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' Successfuly read  freedrift files...'
	if(lroot)write(lu_out,*)

c-------------------------------------
c	Read observed data
c------------------------------------

c set everthing manual for first try

        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' Imposed Parameter space'
        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' nd = 4, Ca, thetaA, Co, thetaO'
        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' Adjusted Parameter space'
        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' nd = 4, Na, Ro,  thetaA, thetaO'
        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' Adjusted Parameter space 2'
        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' nd = 4, Na2, Ro_p,  thetaO, thetaA - thetaOO'
        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' Adjusted Parameter special case - thetaA = constant'
        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' nd = 3, Na2, Ro_p,  thetaO, thetaA = ',thAC,' a constant'
        if(lroot)write(lu_out,*)
        if(lroot)write(lu_out,*)' Now invert ',nbals,' problems with same parameters'

	do i = 1,nbals
        	if(lroot)write(lu_out,*)' Problem ',i
        	if(lroot)write(lu_out,*)' Wind_mag = ',wind_mag(i)
        	if(lroot)write(lu_out,*)' I_O_mag  = ',o_i_mag(i)
        	if(lroot)write(lu_out,*)' GEO_mag  = ',geo_mag(i)
	end do
c we have 4 dimension for this case 
	nd = 3	

c Setting up constants used
	

c Na = np.sqrt((rhoa*Ca)/(rhoo*Co))
c vel_scale = Na*wind_mag
c Ro = rhoi*hice*fc/(rhoo*Co*vel_scale)

c d1 = Na Nansen number

	ranges(1,1) = n2a_min

	ranges(2,1) = n2a_max 
c d2 = Ro Rossby radius

	ranges(1,2) = rop_min

	ranges(2,2) = rop_max
c d3 = thetaO ocean turning

	ranges(1,3) = thA_min
	ranges(2,3) = thA_max
c d4 = thetaAtoO ocean turning

c	ranges(1,4) = thO_min
c	ranges(2,4) = thO_max

c now setting the scales array, using the default case.

	scales(1) = -1
	scales(2) =  0
	scales(3) =  0
	scales(4) =  0
c	scales(5) =  0

			
        return
        end
c
c-------------------------------------------------------------------------
c
c	forward - performs forward modelling for user supplied problem.
c		  In this case it calculates predicted receiver function
c		  for a single model and calculates the misfit measure
c		  between observation and prediction.
c
c	Input: 
c	      nd		:Number of dimensions in parameter space
c	      model(nd)	:input velocity model
c
c	Output:
c	      lppd		:negative log(ppd)
c
c	Comments:
c		 This routine allows the user to perform the forward 
c		 modelling and define an a posterior probability density
c		 function using the resulting mismatch with the observed
c		 data. Note that the output quanity is the negative
c		 natural log of the ppd. This is equivalent to the 
c		 misfit function in most problems. 
c
c				M. Sambridge, RSES (ANU), April 1998. 
c
c-------------------------------------------------------------------------
c 
        subroutine forward(nd,model,lppd)

c						initialize receiver
c						function forward modelling
        include 'freedrift_subs/freedrift_param.inc'

        real*4          lppd
c        real*4          misfitval, penality
        real*4          model(nd)
        real*4          model_use(nd-1)
c 
c	reals for the forward model

	parameter 	(nbals_max = 100)

        integer         nbals
        integer         bflag, bflag_sum, flag_lim
        integer         all_flags(nbals_max)
        real            bal_inc(nbals_max)

        real            nbals_in
        real 		Ca_min, Ca_max, Co_min, Co_max
	real		thA_min, thA_max, thO_min, thO_max
	real		uwind(nbals_max), vwind(nbals_max), wind_mag(nbals_max)
	real		wind_sig(nbals_max)
	real		uo_i(nbals_max), vo_i(nbals_max), o_i_mag(nbals_max)
	real		o_i_sig(nbals_max)
	real		ugeo(nbals_max), vgeo(nbals_max), geo_mag(nbals_max)
	real		geo_sig(nbals_max)
	real		wind_sig_use, ice_sig_use, o_i_sig_use
        real            beta_a(nbals_max), beta_i(nbals_max) 
        real            beta_g(nbals_max), beta_fb(nbals_max)
	real		fc, rhoa, rhoi, rhoo
	real		hifc(nbals_max)  
	real		thAC
	real		Na
        real            pi
        real            misfit_geo(nbals_max), misfit_fb(nbals_max)
        real    fb_ratio
c         parameter       ( fb_ratio = 1.0E0 )
c	parameter 	( rhoa = 1.25E0 )
c	parameter 	( rhoi = 917.0E0 )
c	parameter 	( rhoo = 1026.0E0 )
c	parameter 	( fc   = 1.46E-4 )
c	parameter 	( hice = 1.0E-0 )
        logical         verbose,debug,timing,summary


c
c						Info and Logical unit common 
c						blocks used by NA routines
c 
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                  lu_nad,verbose,debug,timing,summary

        common /NAMPI/iproc,nproc,lroot


        common /freedrift_com/ nbals,
     &			uwind, vwind, wind_mag, wind_sig,
     &                  uo_i, vo_i, o_i_mag, o_i_sig,
     &                  ugeo, vgeo, geo_mag, geo_sig,
     &                  beta_a, beta_i, beta_g, beta_fb,
     &                  rhoa, rhoi, rhoo, hifc, 
     &                  thAC,
     &                  Ca_min, Ca_max, Co_min, Co_max,
     &                  thA_min, thA_max, thO_min, thO_max
c

c converting new model(3) to old model(4) using thAC

	model_use(1) = model(1)
	model_use(2) = model(2)
	model_use(3) = model(3)
	model_use(4) = thAC - model(3)

	do i=1,nbals	
c       	write(lu_out,*)' doing a forward number ',i

c note that the errors are now dimensional fb_ratio nondem
		

c       	fb_ratio = (wind_sig(i)/wind_mag(i) +
c    &          	     o_i_sig(i)/o_i_mag(i)  +
c    &          	     geo_sig(i)/geo_mag(i) )/2
        	fb_ratio = max(wind_sig(i)/wind_mag(i) ,
     &          	     o_i_sig(i)/o_i_mag(i),
     &          	     geo_sig(i)/geo_mag(i)  )

c		 write(lu_out,*)'beta_a = ',beta_a(i)

        	call geo_misfit(
     &          	model_use,
     &          	uwind(i), vwind(i), wind_mag(i), wind_sig(i),
     &          	uo_i(i), vo_i(i), o_i_mag(i), o_i_sig(i),
     &          	ugeo(i), vgeo(i), geo_mag(i), geo_sig(i),
     &          	hifc(i), rhoi,
     &                  beta_a(i), beta_i(i), beta_g(i), 
     &          	misfit_geo(i) )
c       	write(lu_out,*)' finished a  forward number ',i

        	call fb_misfit(
     &          	model_use,
     &          	uwind(i), vwind(i), wind_mag(i), 
     &          	uo_i(i), vo_i(i), o_i_mag(i), 
     &          	ugeo(i), vgeo(i), geo_mag(i),
     &          	hifc(i), rhoi,
     &          	beta_fb(i), fb_ratio, misfit_fb(i) )
c       	write(lu_out,*)' finished a  forward number ',i


	end do

	
c	add up all the misfits... 

	lppd = 0.0D0

	do i = 1, nbals
c       	write(lu_out,*)' adding up the misfits',i
		lppd = lppd +  misfit_geo(i) + misfit_fb(i)
	end do
c      	write(lu_out,*)' adding up the misfits',lppd

c	average out the misfits, by the number of dimensional misfits
c	a dimensional misfit is an observational comparison
c	FB is not dimensional
c	currently nbals * 2 dimensional misfits
	lppd = lppd/nbals/2

	return

	end

c-------------------------------------------------------------------------
c
c	writemodels - user supplied routine to write out models produced
c		      by Neighbourhood algorithm in user's own format.
c
c	Input: 
c	      nd		  :number of dimensions in parameter space
c	      ntot		  :number of models generated by NA 
c	      models(nd,ntot)     :models generated by NA
c	      misfit 		  :array of model misfits (-lppd's)
c	      ns1  		  :initial sample size used by NA
c	      ns2  		  :normal sample size used by NA
c	      itmax  		  :number of iterations
c	      nh_max  		  :maximum length of nad file header 
c
c	Output:         
c	      nh  		  :length of nad file header 
c	      header(nh)  	  :character string containing nad file header
c
c	Comments:
c	         This routine allows the user to write out the models
c		 produced by the NA in their own format. The three 
c		 parameters ns1, ns2 and itmax define the samples sizes
c		 and number of iterations taken by the NA. Initially ns1
c		 random samples are generated, and then itmax sets of ns2
c		 models are generated and so ntot = ns1 + ns2*itmax. 
c
c		 The user may if they wish write their own information 
c		 into the `user reserved' part of NAD file header.
c		 (See example below for details).
c
c				M. Sambridge, RSES (ANU), Oct 1999. 
c
c-------------------------------------------------------------------------
c 
        subroutine writemodels
     &             (nd, ntot, models, misfit, ns1, ns2, itmax,
     &              nh_max, nh, header)

c	first attmept, will just print the 4 parameters to the screen along with the misfit.

c	include 'freedrift_subs/freedrift_param.inc'

c						NA variables and arrays
        integer         nbals
        integer         nbals_max
        integer         bflag, bflag_sum, flag_lim
	parameter 	(nbals_max = 100)
        integer         all_flags(nbals_max)
        real            bal_inc(nbals_max)
        real*4          models(nd,*)
        real*4          misfit(ntot)
        real*4          mfitmin
        real*4          mfitminc
        real*4          mfitmean
        real 		Ca_min, Ca_max, Co_min, Co_max
	real		thA_min, thA_max, thO_min, thO_max
	real		uwind(nbals_max), vwind(nbals_max), wind_mag(nbals_max)
	real		wind_sig(nbals_max)
	real		uo_i(nbals_max), vo_i(nbals_max), o_i_mag(nbals_max)
	real		o_i_sig(nbals_max)
	real		ugeo(nbals_max), vgeo(nbals_max), geo_mag(nbals_max)
	real		geo_sig(nbals_max)
        real            beta_a(nbals_max), beta_i(nbals_max) 
        real            beta_g(nbals_max), beta_fb(nbals_max)
	real		fc, rhoa, rhoi, rhoo
	real		hifc(nbals_max)  
	real		thAC

        character*(*)   header

        logical         verbose,debug,timing,summary
        logical         lroot

c						Receiver function variables
c						and arrays
c        real*8          rmodel(max_nd)

c 
c
c						Info and Logical unit common 
c						block used by NA routines
c 
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

        common /NAMPI/iproc,nproc,lroot

        common /freedrift_com/ nbals,
     &			uwind, vwind, wind_mag, wind_sig,
     &                  uo_i, vo_i, o_i_mag, o_i_sig,
     &                  ugeo, vgeo, geo_mag, geo_sig,
     &                  beta_a, beta_i, beta_g, beta_fb,
     &                  rhoa, rhoi, rhoo, hifc, 
     &                  thAC,
     &                  Ca_min, Ca_max, Co_min, Co_max,
     &                  thA_min, thA_max, thO_min, thO_max

c for simple case - just write the model to screen 
c	parameters
c	Na
c	Ro
c	thetaA
c	thetaO
c 	then the misfit too



c						write out models
c						at each iteration
        mfitmin = misfit(1)
        ns = ns1
        np = 0
        mopt = 1
        moptc = 1
c						turn off writing to 
c						standard out by setting
c						lu to zero
c	lu_out2 = lu_out
c        lu_out2 = 0

c						loop over iterations
        do it=1,itmax+1
           mfitminc = misfit(np+1)
           mfitmean = 0.d0
	   moptc = np + 1
c						find minimum and 
c						mean misfit
           do i=1,ns
              jj = np + i
              if(misfit(jj).lt.mfitmin)then
                 mfitmin = misfit(jj)
                 mopt = jj
              end if
              if(misfit(jj).lt.mfitminc)then
                 mfitminc = misfit(jj)
                 moptc = jj
              end if
c              mfitminc = min(mfitminc,misfit(jj))
              mfitmean = mfitmean + misfit(jj)
           end do
           mfitmean = mfitmean/dble(ns)
c						write out all models
c						from this iteration
c						to receiver function
c						output file.

c           write(lu_mod,801) it-1, mfitmin, mfitmean, mfitminc
c           do i=1,ns
c                jj = np + i
c                call display_model
c     &               (lu_mod, i, models(1,jj), nd, misfit(jj) )
c           end do
           np = np + ns
           ns = ns2
c                                               Write out summary of
c                                               optimum model to
c						receiver function file
c						and NA summary file.
c 
c           call output_summary(
c     &                  lu_out2, lu_sum, it-1, models(1,mopt), nd,
c     &                  np, mfitmin, mfitmean, mfitminc, mopt)
c
c	instead - simple - write the best for this iteration to the sreen
c 	write(*,*) 'Iteration number ',it
c 	write(*,*) 'Misfit for this iteration'
c 	write(*,*) 'Mistfit mean = ',mfitmean
c 	write(*,*) 'Mistfit best = ',mfitminc
c 	write(*,*) 'for model:'
c 	write(*,*) 'Na     = ',models(1,moptc)
c 	write(*,*) 'Ro     = ',models(2,moptc)
c 	write(*,*) 'ThetaA = ',models(3,moptc)
c 	write(*,*) 'ThetaO = ',models(4,moptc)
c 	write(*,*) 'Mistfit best overall = ',mfitmin
        end do
c                                               Write out final model
c 

	write(*,*) '---'
	write(*,*) 'Mistfit best overall = ',mfitmin
	write(*,*) 'for model:'
	write(*,*) 'Na2    = ',models(1,moptc)
	write(*,*) 'Ro_p   = ',models(2,moptc)
	write(*,*) 'ThetaO = ',models(3,moptc)
c	write(*,*) 'ThetaO = ',models(4,moptc)

	write(*,*) '-------------------'
c	write(*,*) 'Total convergence errors = ',bflag_sum

c	do i = 1,nbals
c        	if(lroot)write(lu_out,*)' Problem ',i,' Flags = ',all_flags(i) ,bal_inc(i)
c	end do
		

c------------------- Put together output files ----------------------

c
c        close(lu_mod)
c        close(lu_sum)
c        close(lu_out)
c        close(lu_out2)

        return
        end
